{- | PCRE Wrapper & replacement utilities. -}

module PCRE.REPlacement
  ( REPlacement )
where

import Prelude  ( Float, (+), (-), fromIntegral )

-- array -------------------------------

import Data.Array  ( assocs )

-- base --------------------------------

import Control.Applicative  ( pure, many, some )
import Control.Exception    ( Exception )
import Control.Monad        ( foldM, join, return, sequence )
import Control.Monad.Fail   ( MonadFail( fail ) )
import Data.Bifunctor       ( first )
import Data.Eq              ( Eq( (==) ) )
import Data.Function        ( ($), (&), const, id )
import Data.List            ( dropWhile, lookup, reverse )
import Data.List.NonEmpty   ( NonEmpty( (:|) ), nonEmpty )
import Data.Maybe           ( fromMaybe, maybe )
import Data.String          ( IsString )
import GHC.Stack            ( CallStack, HasCallStack, callStack )
import System.Exit          ( ExitCode )
import System.IO            ( IO )
import Text.Read            ( read )
import Text.Show            ( Show( show ) )

-- base-unicode-symbols ----------------

import Data.Bool.Unicode        ( (‚àß) )
import Data.Eq.Unicode          ( (‚â°) )
import Data.Function.Unicode    ( (‚àò) )
import Data.Monoid.Unicode      ( (‚äï) )
import Prelude.Unicode          ( ‚Ñ§ )
import Numeric.Natural.Unicode  ( ‚Ñï )

-- data-textual ------------------------

import Data.Textual  ( Printable( print ), toText )

-- has-callstack -----------------------

import HasCallstack  ( HasCallstack( callstack ) )

-- hashable ----------------------------

import Data.Hashable  ( Hashable )

-- index -------------------------------

import Index  ( HasIndex( Elem, Indexer, index ), (!!) )

-- lens --------------------------------

import Control.Lens.Lens    ( Lens', lens )
import Control.Lens.Prism   ( Prism', prism' )
import Control.Lens.Review  ( (#) )

-- monaderror-io -----------------------

import MonadError           ( fromRight )

-- mtl ---------------------------------

import Control.Monad.Except  ( MonadError, throwError )

-- more-unicode ------------------------

import Data.MoreUnicode.Applicative  ( (‚à§), (‚äµ), (‚ã´), (‚ã™) )
import Data.MoreUnicode.Char         ( ‚ÑÇ )
import Data.MoreUnicode.Either       ( ùîº, pattern ùï∑, pattern ùïΩ )
import Data.MoreUnicode.Functor      ( (‚ä≥), (‚ä≥‚ä≥), (‚ä≤) )
import Data.MoreUnicode.Lens         ( (‚ä£), (‚ä¢) )
import Data.MoreUnicode.Maybe        ( ùïÑ, pattern ùïµ, pattern ùïπ )
import Data.MoreUnicode.Monad        ( (‚â´) )
import Data.MoreUnicode.Monoid       ( —é )
import Data.MoreUnicode.String       ( ùïä )
import Data.MoreUnicode.Text         ( ùïã )

-- parsec ------------------------------

import Text.Parsec.Prim   ( ParsecT, Stream )

-- parsec-plus -------------------------

import Parsec.Error  ( ParseError )
import ParsecPlus    ( Parsecable( parser, parsec ), eitherParsec, parse )

-- parsers -----------------------------

import Text.Parser.Char         ( CharParsing, alphaNum, char, letter
                                , noneOf, oneOf, spaces, string )
import Text.Parser.Combinators  ( eof, option, sepBy )

-- parser-plus -------------------------

import ParserPlus  ( digits, parseBackslashedChar, stringMaybeDQuoted, tries )

-- quasiquoting ------------------------

import QuasiQuoting  ( QuasiQuoter, liftParsec, mkQQExp )

-- regex -------------------------------

import Text.RE.Replace  ( Capture( Capture, captureLength, captureOffset
                                 , captureSource, capturedText )
                        , CaptureID( IsCaptureName, IsCaptureOrdinal )
                        , CaptureName( CaptureName, getCaptureName )
                        , CaptureOrdinal( CaptureOrdinal )
                        , Match
                        , (!$$)
                        , captureNames, findCaptureID, matchArray, matchCapture
                        , matchCaptures, matchSource, matchedText
                        )

-- regex-with-pcre ---------------------

import Text.RE.PCRE.Text  ( RE, (?=~), compileRegex, re, reSource )

-- tasty -------------------------------

import Test.Tasty  ( TestName, TestTree, testGroup )

-- tasty-hunit -------------------------

import Test.Tasty.HUnit  ( (@=?), testCase )

-- tasty-plus --------------------------

import TastyPlus  ( assertIsLeft, assertRight, assertSuccess
                  , runTestsP, runTestsReplay, runTestTree )

-- template-haskell --------------------

import Language.Haskell.TH         ( Name, Q )
import Language.Haskell.TH.Syntax  ( Exp( AppE, ConE ), Lift( liftTyped )
                                   , TExp( TExp ) )

-- text --------------------------------

import Data.Text     ( append, drop, last, length, map, pack, replicate
                     , singleton, take, toTitle, unpack, zip )

-- text-printer ------------------------

import qualified Text.Printer  as  P

-- tfmt --------------------------------

import Text.Fmt  ( fmt )

-- unordered-containers ----------------

import qualified Data.HashMap.Lazy  as  HashMap
import Data.HashMap.Lazy  ( HashMap, (!?), foldMapWithKey )

--------------------------------------------------------------------------------

{- | An RE with its replacement pattern. -}
data REPlacement = REPlacement RE ReplText

instance Eq REPlacement where
  (REPlacement r rtext) == (REPlacement r' rtext') =
    (reSource r ‚â° reSource r') ‚àß (rtext ‚â° rtext')

instance Show REPlacement where
  show (REPlacement r rtext) =
    [fmt|REPlacement: ¬ª%s¬´ ‚Üí ¬ª%t¬´|] (reSource r) (toText rtext)

instance Parsecable REPlacement where
  parser = REPlacement ‚ä≥ (unREParsecable ‚ä≥ parser) ‚ã™ many (char '\t')
                       ‚äµ (eitherParsec stringMaybeDQuoted
                                       (\ s ‚Üí parsec @_ @ParseError s s))

-- that's all, folks! ----------------------------------------------------------
